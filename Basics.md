# JDK, JRE & JVM
**Java Development Kit** (JDK) is a software development environment used for developing Java applications and applets. 

It includes:

    - Java Runtime Environment (JRE), 
    
    - Interpreter/loader (Java), 
    
    - Compiler (javac), 
    
    - Archiver (jar), 
    
    - Documentation generator (Javadoc), 
    
    - Other tools needed in Java development.
    
JDK (Java Development Kit) is a Kit that provides the environment to develop and execute(run) the Java program. JDK is a kit(or package) that includes two things

a) Development Tools(to provide an environment to develop your java programs)

b) JRE (to execute your java program).

**JRE** stands for “Java Runtime Environment”
The Java Runtime Environment provides the minimum requirements for executing a Java application; Consists of the Java Virtual Machine (JVM), core classes, and supporting files. 

JRE (Java Runtime Environment) is an installation package that provides an environment to only run(not develop) the java program(or application)onto your machine.

Components of JRE are as follows:

Deployment technologies: Including deployment, Java Web Start, and Java Plug-in.

User interface toolkits: Including Abstract Window Toolkit (AWT), Swing, Java 2D, Image I/O, Print Service, Sound, drag, and drop (DnD).

Integration libraries: Including Interface Definition Language (IDL), Java Database Connectivity (JDBC), Java Naming and Directory Interface (JNDI), Remote Method Invocation (RMI), Remote Method Invocation Over Internet Inter-Orb Protocol (RMI-IIOP), and scripting.

Other base libraries: Including international support, input/output (I/O), extension mechanism, Beans, Java Management Extensions (JMX), Java Native Interface (JNI), Math, Networking, Override Mechanism, Security, Serialization, and Java for XML Processing (XML JAXP).

Lang and util base libraries: Including lang and util, management, versioning, zip, instrument, reflection, Collections, Concurrency Utilities, Java Archive (JAR), Logging, Preferences API, Ref Objects, and Regular Expressions.

Java Virtual Machine (JVM): Including Java HotSpot Client and Server Virtual Machines.

**JVM**, which stands out for java virtual machines. It is as follows:
A specification where the working of Java Virtual Machine is specified. But implementation provider is independent to choose the algorithm. 
Its implementation has been provided by different vendors like Oracle, IBM, Amazon, RedHat and others.
An implementation is a computer program that meets the requirements of the JVM specification.
A Runtime instance of JVM is created, whenever we write a java command on the command prompt to run the java class
JVM is responsible for executing the java program line by line, hence it is also known as an interpreter.

# How JVM Works

JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a Java code. JVM is a part of JRE(Java Runtime Environment).

Java applications are called WORA (Write Once Run Anywhere).

On compilation Java compiler generates .class from .java files with same name as in .java file. This .class file goes into various steps when we run it. These steps together describe the whole JVM. 

![image info](./JVM.png)

**Class Loader Subsystem**

Responsible for three activities. 

- Loading

The Class loader reads the “.class” file, generate the corresponding binary data and save it in the method area. For each “.class” file, JVM stores the following information in the method area.

The fully qualified name of the loaded class and its immediate parent class.

Whether the “.class” file is related to Class or Interface or Enum.

Modifier, Variables and Method information etc.

After loading the “.class” file, JVM creates an object of type Class to represent this file in the heap memory. This object is of type Class predefined in java.lang package. 
These Class object can be used by the programmer for getting class level information like the name of the class, parent name, methods and variable information etc. To get this object reference we can use getClass() method of Object class.

- Linking
  
Performs verification, preparation, and (optionally) resolution.

Verification: IEnsures the correctness of the .class file i.e. it checks whether this file is properly formatted and generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError. This activity is done by the component ByteCodeVerifier. Once this activity is completed then the class file is ready for compilation.

Preparation: JVM allocates memory for class static variables and initializing the memory to default values. 

Resolution: It is the process of replacing symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.

- Initialization

In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy. 
In general, there are three class loaders : 

Bootstrap class loader: Every JVM implementation must have a bootstrap class loader, capable of loading trusted classes. It loads core java API classes present in the “JAVA_HOME/jre/lib” directory. This path is popularly known as the bootstrap path. It is implemented in native languages like C, C++.

Extension class loader: It is a child of the bootstrap class loader. It loads the classes present in the extensions directories “JAVA_HOME/jre/lib/ext”(Extension path) or any other directory specified by the java.ext.dirs system property. It is implemented in java by the sun.misc.Launcher$ExtClassLoader class.

System/Application class loader: It is a child of the extension class loader. It is responsible to load classes from the application classpath. It internally uses Environment Variable which mapped to java.class.path. It is also implemented in Java by the sun.misc.Launcher$AppClassLoader class.

# Shallow Copy
- It is fast as no new memory is allocated.
- Changes in one entity is reflected in other entity.
- The default version of the clone() method supports shallow copy.
- A shallow copy is less expensive.
- Cloned object and the original object are not disjoint.
# Deep Copy
- It is slow as new memory is allocated.
- Changes in one entity are not reflected in changes in another identity.
- In order to make the clone() method support the deep copy, one has to override the clone() method.
- Deep copy is highly expensive.
- Cloned object and the original object are disjoint.
# What is the order of execution of instance initialization blocks, static initialization blocks, and constructors?
The order of execution is:
- Static initialization blocks (when the class is loaded).
- Instance initialization blocks (when an instance is created).
- Constructors (after the instance initialization blocks).

```
class Example {
    static int a;
    int b;
    // Static initialization block
    static {
        a = 1;
        System.out.println("Static Initialization Block");
    }
    // Instance initialization block
    {
        b = 2;
        System.out.println("Instance Initialization Block");
    }
    Example() {
        System.out.println("Constructor");
    }
    public static void main(String[] args) {
        new Example();
    }
}
```
Output : 
Static Initialization Block

Instance Initialization Block

Constructor
# What happens if there is an exception in a static initialization block?
If an exception occurs in a static initialization block, it prevents the class from being loaded, resulting in a `ExceptionInInitializerError`. This error occurs the first time the class is accessed.

```
class Example {
    static {
        System.out.println("Static Block");
        if (true) {
            throw new RuntimeException("Exception in static block");
        }
    }
    
    public static void main(String[] args) {
        try {
            new Example();
        } catch (Throwable t) {
            t.printStackTrace();
        }
    }
}
```
Output:

Static Block
java.lang.ExceptionInInitializerError
Caused by: java.lang.RuntimeException: Exception in static block
    at Example.<clinit>(Example.java:6)
# Can you access instance variables in a static initialization block?
No, instance variables cannot be accessed directly in a static initialization block because static blocks do not belong to an instance of the class. They are executed when the class is loaded and no instance exists at that point.
# Can you call a static method in an instance initialization block?
Yes, you can call a static method in an instance initialization block since static methods belong to the class and can be accessed without an instance.
```
class Example {
    static void staticMethod() {
        System.out.println("Static Method");
    }
    
    {
        staticMethod(); // Calling static method
        System.out.println("Instance Block");
    }
    
    Example() {
        System.out.println("Constructor");
    }
    
    public static void main(String[] args) {
        new Example();
    }
}
```
Output:

Static Method

Instance Block

Constructor

``Example`` :
```
class ExampleBlock {
    {
        System.out.println("ExampleBlock : Instance Initialization Block - 1");
    }
    static {
        System.out.println("ExampleBlock : Static Instance Initialization Block - 1");
    }
    ExampleBlock() {
        System.out.println("ExampleBlock : Default Constructor");
    }
}
class SubExampleBlock extends ExampleBlock {
    {
        System.out.println("SubExampleBlock : Instance Initialization Block - 1");
    }
    static {
        System.out.println("SubExampleBlock : Static Instance Initialization Block - 1");
    }
    SubExampleBlock() {
        System.out.println("SubExampleBlock : Default Constructor");
    }
}

public class StaticInitializationBlockEx {
    public static void main(String[] args) {
        ExampleBlock subExampleBlock = new SubExampleBlock();
    }
}
```
Output:

ExampleBlock : Static Instance Initialization Block - 1

SubExampleBlock : Static Instance Initialization Block - 1

ExampleBlock : Instance Initialization Block - 1

ExampleBlock : Default Constructor

SubExampleBlock : Instance Initialization Block - 1

SubExampleBlock : Default Constructor
